{
    "LinkedList Template": {
        "prefix": "!linkedlist",
        "body": [
            "import java.io.*", 
            "",
            "// Java program to implement",
            "// a Singly Linked List",
            "public class LinkedList {",
            "",
            "    Node head, // head of list",
            "",
            "    // Linked list Node.",
            "    // Node is a static nested class",
            "    // so main() can access it",
            "    static class Node {",
            "",
            "        int data,",
            "        Node next;",
            "",
            "        // Constructor",
            "        Node(int d)",
            "        {",
            "            data = d,",
            "            next = null;",
            "        },",
            "    },",
            "",
            "    // **************INSERTION**************",
            "",
            "    // Method to insert a new node",
            "    public static LinkedList insert(LinkedList list,",
            "                                    int data)",
            "    {",
            "        // Create a new node with given data",
            "        Node new_node = new Node(data),",
            "        new_node.next = null;",
            "",
            "        // If the Linked List is empty,",
            "        // then make the new node as head",
            "        if (list.head == null) {",
            "            list.head = new_node,",
            "        },",
            "        else {",
            "            // Else traverse till the last node",
            "            // and insert the new_node there",
            "            Node last = list.head,",
            "            while (last.next != null) {",
            "                last = last.next,",
            "            },",
            "",
            "            // Insert the new_node at last node",
            "            last.next = new_node,",
            "        },",
            "",
            "        // Return the list by head",
            "        return list,",
            "    },",
            "",
            "    // **************TRAVERSAL**************",
            "",
            "    // Method to print the LinkedList.",
            "    public static void printList(LinkedList list)",
            "    {",
            "        Node currNode = list.head,",
            "",
            "        System.out.print(\"\\nLinkedList: \"),",
            "",
            "        // Traverse through the LinkedList",
            "        while (currNode != null) {",
            "            // Print the data at current node",
            "            System.out.print(currNode.data + \" \"),",
            "",
            "            // Go to next node",
            "            currNode = currNode.next,",
            "        },",
            "        System.out.println(\"\\n\"),",
            "    },",
            "",
            "    // **************DELETION BY KEY**************",
            "",
            "    // Method to delete a node in the LinkedList by KEY",
            "    public static LinkedList deleteByKey(LinkedList list,",
            "                                         int key)",
            "    {",
            "        // Store head node",
            "        Node currNode = list.head, prev = null,",
            "",
            "        //",
            "        // CASE 1:",
            "        // If head node itself holds the key to be deleted",
            "",
            "        if (currNode != null && currNode.data == key) {",
            "            list.head = currNode.next, // Changed head",
            "",
            "            // Display the message",
            "            System.out.println(key + \" found and deleted\"),",
            "",
            "            // Return the updated List",
            "            return list,",
            "        },",
            "",
            "        //",
            "        // CASE 2:",
            "        // If the key is somewhere other than at head",
            "        //",
            "",
            "        // Search for the key to be deleted,",
            "        // keep track of the previous node",
            "        // as it is needed to change currNode.next",
            "        while (currNode != null && currNode.data != key) {",
            "            // If currNode does not hold key",
            "            // continue to next node",
            "            prev = currNode,",
            "            currNode = currNode.next,",
            "        },",
            "",
            "        // If the key was present, it should be at currNode",
            "        // Therefore the currNode shall not be null",
            "        if (currNode != null) {",
            "            // Since the key is at currNode",
            "            // Unlink currNode from linked list",
            "            prev.next = currNode.next,",
            "",
            "            // Display the message",
            "            System.out.println(key + \" found and deleted\"),",
            "        },",
            "",
            "        //",
            "        // CASE 3: The key is not present",
            "        //",
            "",
            "        // If key was not present in linked list",
            "        // currNode should be null",
            "        if (currNode == null) {",
            "            // Display the message",
            "            System.out.println(key + \" not found\"),",
            "        },",
            "",
            "        // return the List",
            "        return list,",
            "    },",
            "",
            "    // **************DELETION AT A POSITION**************",
            "",
            "    // Method to delete a node in the LinkedList by POSITION",
            "    public static LinkedList",
            "    deleteAtPosition(LinkedList list, int index)",
            "    {",
            "        // Store head node",
            "        Node currNode = list.head, prev = null,",
            "",
            "        //",
            "        // CASE 1:",
            "        // If index is 0, then head node itself is to be",
            "        // deleted",
            "",
            "        if (index == 0 && currNode != null) {",
            "            list.head = currNode.next, // Changed head",
            "",
            "            // Display the message",
            "            System.out.println(",
            "                index + \" position element deleted\"),",
            "",
            "            // Return the updated List",
            "            return list,",
            "        },",
            "",
            "        //",
            "        // CASE 2:",
            "        // If the index is greater than 0 but less than the",
            "        // size of LinkedList",
            "        //",
            "        // The counter",
            "        int counter = 0,",
            "",
            "        // Count for the index to be deleted,",
            "        // keep track of the previous node",
            "        // as it is needed to change currNode.next",
            "        while (currNode != null) {",
            "",
            "            if (counter == index) {",
            "                // Since the currNode is the required",
            "                // position Unlink currNode from linked list",
            "                prev.next = currNode.next,",
            "",
            "                // Display the message",
            "                System.out.println(",
            "                    index + \" position element deleted\"),",
            "                break,",
            "            },",
            "            else {",
            "                // If current position is not the index",
            "                // continue to next node",
            "                prev = currNode,",
            "                currNode = currNode.next,",
            "                counter++,",
            "            },",
            "        },",
            "",
            "        // If the position element was found, it should be",
            "        // at currNode Therefore the currNode shall not be",
            "        // null",
            "        //",
            "        // CASE 3: The index is greater than the size of the",
            "        // LinkedList",
            "        //",
            "        // In this case, the currNode should be null",
            "        if (currNode == null) {",
            "            // Display the message",
            "            System.out.println(",
            "                index + \" position element not found\"),",
            "        },",
            "",
            "        // return the List",
            "        return list,",
            "    },",
            "",
            "    // **************MAIN METHOD**************",
            "",
            "    // method to create a Singly linked list with n nodes",
            "    public static void main(String[] args)",
            "    {",
            "        /* Start with the empty list. */",
            "        LinkedList list = new LinkedList(),",
            "",
            "        //",
            "        // ******INSERTION******",
            "        //",
            "",
            "        // Insert the values",
            "        list = insert(list, 1),",
            "        list = insert(list, 2),",
            "        list = insert(list, 3),",
            "        list = insert(list, 4),",
            "        list = insert(list, 5),",
            "        list = insert(list, 6),",
            "        list = insert(list, 7),",
            "        list = insert(list, 8),",
            "",
            "        // Print the LinkedList",
            "        printList(list),",
            "",
            "        //",
            "        // ******DELETION BY KEY******",
            "        //",
            "",
            "        // Delete node with value 1",
            "        // In this case the key is ***at head***",
            "        deleteByKey(list, 1),",
            "",
            "        // Print the LinkedList",
            "        printList(list),",
            "",
            "        // Delete node with value 4",
            "        // In this case the key is present ***in the",
            "        // middle***",
            "        deleteByKey(list, 4),",
            "",
            "        // Print the LinkedList",
            "        printList(list),",
            "",
            "        // Delete node with value 10",
            "        // In this case the key is ***not present***",
            "        deleteByKey(list, 10),",
            "",
            "        // Print the LinkedList",
            "        printList(list),",
            "",
            "        //",
            "        // ******DELETION AT POSITION******",
            "        //",
            "",
            "        // Delete node at position 0",
            "        // In this case the key is ***at head***",
            "        deleteAtPosition(list, 0),",
            "",
            "        // Print the LinkedList",
            "        printList(list),",
            "",
            "        // Delete node at position 2",
            "        // In this case the key is present ***in the",
            "        // middle***",
            "        deleteAtPosition(list, 2),",
            "",
            "        // Print the LinkedList",
            "        printList(list),",
            "",
            "        // Delete node at position 10",
            "        // In this case the key is ***not present***",
            "        deleteAtPosition(list, 10),",
            "",
            "        // Print the LinkedList",
            "        printList(list),",
            "    },",
            "}"
             
        ],
        "description": "Creates Implementation of LinkedList with all default methods"
    },


    "ArrayList Template":{
        "prefix": "!arraylist",
        "body": [
            "import java.util.Arrays;", 
            "",
            "public class ArrayList<E> {",
            "    private static final int DEFAULT_CAPACITY = 10,",
            "    private static final Object[] EMPTY_ARRAY = {},",
            "",
            "    private Object[] elements,",
            "    private int size,",
            "",
            "    public ArrayList() {",
            "        elements = EMPTY_ARRAY,",
            "        size = 0,",
            "    },",
            "",
            "    public ArrayList(int initialCapacity) {",
            "        if (initialCapacity < 0) {",
            "            throw new IllegalArgumentException(\"Illegal Capacity: \" + initialCapacity),",
            "        },",
            "        if (initialCapacity == 0) {",
            "            elements = EMPTY_ARRAY,",
            "        } else {",
            "            elements = new Object[initialCapacity],",
            "        },",
            "        size = 0,",
            "    },",
            "",
            "    public int size() {",
            "        return size,",
            "    },",
            "",
            "    public boolean isEmpty() {",
            "        return size == 0,",
            "    },",
            "",
            "    public boolean contains(E element) {",
            "        return indexOf(element) >= 0,",
            "    },",
            "",
            "    public int indexOf(E element) {",
            "        if (element == null) {",
            "            for (int i = 0; i < size; i++) {",
            "                if (elements[i] == null) {",
            "                    return i,",
            "                },",
            "            },",
            "        } else {",
            "            for (int i = 0; i < size; i++) {",
            "                if (element.equals(elements[i])) {",
            "                    return i,",
            "                },",
            "            },",
            "        },",
            "        return -1,",
            "    },",
            "",
            "    public int lastIndexOf(E element) {",
            "        if (element == null) {",
            "            for (int i = size - 1; i >= 0; i--) {",
            "                if (elements[i] == null) {",
            "                    return i,",
            "                },",
            "            },",
            "        } else {",
            "            for (int i = size - 1; i >= 0; i--) {",
            "                if (element.equals(elements[i])) {",
            "                    return i,",
            "                },",
            "            },",
            "        },",
            "        return -1,",
            "    },",
            "",
            "    public E get(int index) {",
            "        if (index < 0 || index >= size) {",
            "            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size),",
            "        },",
            "        return (E) elements[index],",
            "    },",
            "",
            "    public void set(int index, E element) {",
            "        if (index < 0 || index >= size) {",
            "            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size),",
            "        },",
            "        elements[index] = element,",
            "    },",
            "",
            "    public boolean add(E element) {",
            "        ensureCapacity(size + 1),",
            "        elements[size++] = element,",
            "        return true,",
            "    },",
            "",
            "    public void add(int index, E element) {",
            "        if (index < 0 || index > size) {",
            "            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size),",
            "        },",
            "        ensureCapacity(size + 1),",
            "        System.arraycopy(elements, index, elements, index + 1, size - index),",
            "        elements[index] = element,",
            "        size++,",
            "    },",
            "",
            "    public boolean remove(E element) {",
            "        int index = indexOf(element),",
            "        if (index >= 0) {",
            "            remove(index),",
            "            return true,",
            "        },",
            "        return false,",
            "    },",
            "",
            "    public E remove(int index) {",
            "        if (index < 0 || index >= size) {",
            "            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size),",
            "        },",
            "        E removedElement = (E) elements[index],",
            "        int numElementsToMove = size - index - 1,",
            "        if (numElementsToMove > 0) {",
            "            System.arraycopy(elements, index + 1, elements, index, numElementsToMove),",
            "        },",
            "        elements[--size] = null,",
            "        return removedElement,",
            "    },",
            "",
            "    public void clear() {",
            "        Arrays.fill(elements, 0, size, null),",
            "        size = 0,",
            "    },",
            "",
            "    private void ensureCapacity(int minCapacity) {",
            "        if (elements == EMPTY_ARRAY) {",
            "            minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity),",
            "        },",
            "        if (minCapacity - elements.length > 0) {",
            "            int newCapacity = elements.length + (elements.length >> 1),",
            "            if (newCapacity - minCapacity < 0) {",
            "                newCapacity = minCapacity,",
            "            },",
            "            elements = Arrays.copyOf(elements, newCapacity),",
            "        },",
            "    },",
            "",
            "    @Override",
            "    public String toString() {",
            "        if (size == 0) {",
            "            return \"[]\",",
            "        },",
            "        StringBuilder sb = new StringBuilder(),",
            "        sb.append('['),",
            "        for (int i = 0; i < size; i++) {",
            "            sb.append(elements[i]),",
            "            if (i < size - 1) {",
            "                sb.append(\", \"),",
            "            },",
            "        },",
            "        sb.append(']'),",
            "        return sb.toString(),",
            "    },",
            "}"
            

        ],

        

    },
    "HashMap Template":{
        "prefix":"!hashmap",
        "body": [
            "import java.util.ArrayList;", 
            "import java.util.LinkedList;", 
            "import java.util.List;", 
            "", 
            "public class HashMap<K, V> {", 
            "    private static final int DEFAULT_CAPACITY = 16,",
            "    private static final float DEFAULT_LOAD_FACTOR = 0.75f,",
            "",
            "    private List<Entry<K, V>>[] buckets,",
            "    private int size,",
            "    private float loadFactor,",
            "",
            "    public HashMap() {",
            "        this(DEFAULT_CAPACITY, DEFAULT_LOAD_FACTOR),",
            "    },",
            "",
            "    public HashMap(int initialCapacity) {",
            "        this(initialCapacity, DEFAULT_LOAD_FACTOR),",
            "    },",
            "",
            "    public HashMap(int initialCapacity, float loadFactor) {",
            "        if (initialCapacity <= 0) {",
            "            throw new IllegalArgumentException(\"Initial capacity must be a positive number.\"),",
            "        },",
            "        if (loadFactor <= 0 || Float.isNaN(loadFactor)) {",
            "            throw new IllegalArgumentException(\"Load factor must be a positive number.\"),",
            "        },",
            "",
            "        buckets = new LinkedList[initialCapacity],",
            "        for (int i = 0; i < initialCapacity; i++) {",
            "            buckets[i] = new LinkedList<>(),",
            "        },",
            "        this.loadFactor = loadFactor,",
            "        size = 0,",
            "    },",
            "",
            "    public int size() {",
            "        return size,",
            "    },",
            "",
            "    public boolean isEmpty() {",
            "        return size == 0,",
            "    },",
            "",
            "    public boolean containsKey(K key) {",
            "        int bucketIndex = getBucketIndex(key),",
            "        List<Entry<K, V>> bucket = buckets[bucketIndex],",
            "        for (Entry<K, V> entry : bucket) {",
            "            if (entry.key.equals(key)) {",
            "                return true,",
            "            },",
            "        },",
            "        return false,",
            "    },",
            "",
            "    public boolean containsValue(V value) {",
            "        for (List<Entry<K, V>> bucket : buckets) {",
            "            for (Entry<K, V> entry : bucket) {",
            "                if (entry.value.equals(value)) {",
            "                    return true,",
            "                },",
            "            },",
            "        },",
            "        return false,",
            "    },",
            "",
            "    public V get(K key) {",
            "        int bucketIndex = getBucketIndex(key),",
            "        List<Entry<K, V>> bucket = buckets[bucketIndex],",
            "        for (Entry<K, V> entry : bucket) {",
            "            if (entry.key.equals(key)) {",
            "                return entry.value,",
            "            },",
            "        },",
            "        return null,",
            "    },",
            "",
            "    public V put(K key, V value) {",
            "        int bucketIndex = getBucketIndex(key),",
            "        List<Entry<K, V>> bucket = buckets[bucketIndex],",
            "        for (Entry<K, V> entry : bucket) {",
            "            if (entry.key.equals(key)) {",
            "                V oldValue = entry.value,",
            "                entry.value = value,",
            "                return oldValue,",
            "            },",
            "        },",
            "",
            "        bucket.add(new Entry<>(key, value)),",
            "        size++,",
            "        if (size >= buckets.length * loadFactor) {",
            "            resize(),",
            "        },",
            "        return null,",
            "    },",
            "",
            "    public V remove(K key) {",
            "        int bucketIndex = getBucketIndex(key),",
            "        List<Entry<K, V>> bucket = buckets[bucketIndex],",
            "        for (Entry<K, V> entry : bucket) {",
            "            if (entry.key.equals(key)) {",
            "                V value = entry.value,",
            "                bucket.remove(entry),",
            "                size--,",
            "                return value,",
            "            },",
            "        },",
            "        return null,",
            "    },",
            "",
            "    public void clear() {",
            "        for (List<Entry<K, V>> bucket : buckets) {",
            "            bucket.clear(),",
            "        },",
            "        size = 0,",
            "    },",
            "",
            "    private int getBucketIndex(K key) {",
            "        int hashCode = key.hashCode(),",
            "        return hashCode % buckets.length,",
            "    },",
            "",
            "    private void resize() {",
            "        int newCapacity = buckets.length * 2,",
            "        List<Entry<K, V>>[] newBuckets = new LinkedList[newCapacity],",
            "        for (int i = 0; i < newCapacity; i++) {",
            "            newBuckets[i] = new LinkedList<>(),",
            "        },",
            "",
            "        for (List<Entry<K, V>> bucket : buckets) {",
            "            for (Entry<K, V> entry : bucket) {",
            "                int newBucketIndex = getBucketIndex(entry.key, newCapacity),",
            "                newBuckets[newBucketIndex].add(entry),",
            "            },",
            "        },",
            "",
            "        buckets = newBuckets,",
            "    },",
            "",
            "    private int getBucketIndex(K key, int bucketCount) {",
            "        int hashCode = key.hashCode(),",
            "        return hashCode % bucketCount,",
            "    },",
            "",
            "    private static class Entry<K, V> {",
            "        private K key,",
            "        private V value,",
            "",
            "        public Entry(K key, V value) {",
            "            this.key = key,",
            "            this.value = value,",
            "        },",
            "    },",
            "}"
                

        ]
            
    },

    "Array Template":{
        "prefix": "!array",
        "body": [
            "public class Array<T> {",
            "    private static final int DEFAULT_CAPACITY = 10,",
            "",
            "    private T[] elements,",
            "    private int size,",
            "",
            "    public Array() {",
            "        this(DEFAULT_CAPACITY),",
            "    },",
            "",
            "    public Array(int capacity) {",
            "        if (capacity <= 0) {",
            "            throw new IllegalArgumentException(\"Capacity must be a positive number.\"),",
            "        },",
            "        elements = (T[]) new Object[capacity],",
            "        size = 0,",
            "    },",
            "",
            "    public int size() {",
            "        return size,",
            "    },",
            "",
            "    public boolean isEmpty() {",
            "        return size == 0,",
            "    },",
            "",
            "    public void add(T element) {",
            "        ensureCapacity(size + 1),",
            "        elements[size++] = element,",
            "    },",
            "",
            "    public void add(int index, T element) {",
            "        if (index < 0 || index > size) {",
            "            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size),",
            "        },",
            "        ensureCapacity(size + 1),",
            "        System.arraycopy(elements, index, elements, index + 1, size - index),",
            "        elements[index] = element,",
            "        size++,",
            "    },",
            "",
            "    public T get(int index) {",
            "        if (index < 0 || index >= size) {",
            "            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size),",
            "        },",
            "        return elements[index],",
            "    },",
            "",
            "    public void set(int index, T element) {",
            "        if (index < 0 || index >= size) {",
            "            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size),",
            "        },",
            "        elements[index] = element,",
            "    },",
            "",
            "    public T remove(int index) {",
            "        if (index < 0 || index >= size) {",
            "            throw new IndexOutOfBoundsException(\"Index: \" + index + \", Size: \" + size),",
            "        },",
            "        T removedElement = elements[index],",
            "        int numElementsToMove = size - index - 1,",
            "        if (numElementsToMove > 0) {",
            "            System.arraycopy(elements, index + 1, elements, index, numElementsToMove),",
            "        },",
            "        elements[--size] = null,",
            "        return removedElement,",
            "    },",
            "",
            "    public boolean remove(T element) {",
            "        for (int i = 0; i < size; i++) {",
            "            if (elements[i].equals(element)) {",
            "                remove(i),",
            "                return true,",
            "            },",
            "        },",
            "        return false,",
            "    },",
            "",
            "    public boolean contains(T element) {",
            "        for (int i = 0; i < size; i++) {",
            "            if (elements[i].equals(element)) {",
            "                return true,",
            "            },",
            "        },",
            "        return false,",
            "    },",
            "",
            "    public void clear() {",
            "        for (int i = 0; i < size; i++) {",
            "            elements[i] = null,",
            "        },",
            "        size = 0,",
            "    },",
            "",
            "    private void ensureCapacity(int minCapacity) {",
            "        if (minCapacity - elements.length > 0) {",
            "            int newCapacity = elements.length * 2,",
            "            if (newCapacity - minCapacity < 0) {",
            "                newCapacity = minCapacity,",
            "            },",
            "            T[] newElements = (T[]) new Object[newCapacity],",
            "            System.arraycopy(elements, 0, newElements, 0, size),",
            "            elements = newElements,",
            "        },",
            "    },",
            "",
            "    @Override",
            "    public String toString() {",
            "        if (size == 0) {",
            "            return \"[]\",",
            "        },",
            "        StringBuilder sb = new StringBuilder(),",
            "        sb.append('['),",
            "        for (int i = 0; i < size; i++) {",
            "            sb.append(elements[i]),",
            "            if (i < size - 1) {",
            "                sb.append(\", \"),",
            "            },",
            "        },",
            "        sb.append(']'),",
            "        return sb.toString(),",
            "    },",
            "}"
            
        ]
    }
}